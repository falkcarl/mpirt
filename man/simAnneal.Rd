% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MPsearchfunctions.R
\name{simAnneal}
\alias{simAnneal}
\title{Main function that performs simulated annealing (SA)}
\usage{
simAnneal(
  dat,
  k.mat,
  itermax = 1000,
  inittemp = 10,
  type = "aic",
  random = FALSE,
  startimat = NULL,
  step = 1,
  items = 1,
  temptype = "straight",
  ...
)
}
\arguments{
\item{dat}{The data, typically in a format prepared by \code{\link[OpenMx]{mxFactor}}.}

\item{k.mat}{Starting matrix that represents k for each item (e.g., as generated by \code{\link{newkmat}}).}

\item{itermax}{Number of iterations for SA algorithm.}

\item{inittemp}{Staring temperature for SA algorithm.}

\item{type}{Which information criterion to use as the objective function to minimize. Anything supported by \code{\link{getIC}} is currently possible and "aic" or "bic" are typical choices.}

\item{random}{Logical value indicating whether to just automatically accept neighboring models (meaning not actually do SA).}

\item{startimat}{Starting item parameter matrix, if any. Used only for the first iteration.}

\item{step}{Maximum allowed change in k for candidate models. e.g., step 1 -> k=0 to k=1 allowed, but not k=0 to k=2. Smaller steps less likely to have estimation problems.}

\item{items}{How many items' k should be perturbed for computing a neighboring model?}

\item{temptype}{Method for temperature schedule decreases (see \code{\link{newTemp}} function).}

\item{...}{Additional arguments to be passed to \code{\link{fitMP}}.}
}
\value{
A list with the following elements
}
\description{
Main function that performs simulated annealing (SA)
}
\details{
In monotonic polynomial (MP) models, each item may have a different polynomial order. This function performs simulated annealing to select polynomial order.
  Details of the exact implementation are given in Falk (2019). In brief, at a given iteration of the algorithm, a candidate model is generated by
  perturbing the polynomial order for a certain number of items. The candidate model is fit to the data and model fit is compared to the current model.
  If fit improves, the candidate model is accepted and will be the current model in the next iteration. If the candidate model's fit is worse,
  it may still be accepted with some non-zero probability that depends on the discrepancy in fit and the current "temperature" of the algorithm.
  High temperatures will result in a higher probability of accepting a poorer candidate model. In the algorithm, temperature declines towards zero over time, yet depends
  on the temperature schedule and number of iterations(see \code{\link{newTemp}}).

  This function assumes that all items on the test are candidates for higher order polynomials; functionality to restrict the search space is possible, but not yet implemented.
  The only functionality for search space restriction is the highest k to consider for each item, as determined by the size of the matrix
  in \code{k.mat}. Note also that the starting polynomial order is also determined by this matrix.
}
\section{Slots}{

\describe{
\item{\code{k.mat}}{A matrix of the same type as its input that encodes the polynomial order for each item.}

\item{\code{beste}}{A recording of the best objective function encountered from the best fitting model.}

\item{\code{bestk}}{A vector encoding the values of k for the best model.}

\item{\code{bestmod}}{The best fitted \code{mxModel}. This is what may be most useful to pass to other functions or to
extract information from as it is a fitted MP model.}

\item{\code{bestimat}}{The item parameter matrix from the best fitted model (useful if one wants to do more iterations or re-fit the same model).}
}}

\examples{
\donttest{

# For now, just load something from mirt
#library(mirt)
data(Science)

dat <- mxFactor(Science,levels=1:4)
safit <- simAnneal(dat, k.mat=newkmat(0,2,4),
                   itermax = 4*6,
                   inittemp = 5,
                   type = "aic",
                   step = 1,
                   items = 1,
                   temptype = "logarithmic",
                   itemtype=rep("grmp",4))


samod <- safit$bestmod

getIC(samod, "aic") # extract AIC from best model
getkrec(samod, 4) # value of k for each item from best model

}


}
